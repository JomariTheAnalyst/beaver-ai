import { Agent, AgentType, AgentMessage, AgentTask, TaskResult, AgentResponse } from '../agents/base/Agent';
import { logger } from '../utils/logger';
import { v4 as uuidv4 } from 'uuid';

interface ConversationContext {
  projectId?: string;
  userId: string;
  conversationId?: string;
  timestamp: Date;
}

interface StreamListener {
  (data: any): void;
}

export class AgentOrchestrator {
  private agents: Map<AgentType, Agent>;
  private conversations: Map<string, AgentMessage[]>;
  private activeProjects: Map<string, any>;
  private streamListeners: Map<string, StreamListener[]>;

  constructor() {
    this.agents = new Map();
    this.conversations = new Map();
    this.activeProjects = new Map();
    this.streamListeners = new Map();
  }

  registerAgent(agent: Agent): void {
    const agentInfo = agent.getAgentInfo();
    this.agents.set(agentInfo.type, agent);
    agent.activate();
    logger.info(`Registered agent: ${agentInfo.type}`);
  }

  async processMessage(message: string, context: ConversationContext): Promise<AgentResponse> {
    try {
      // Create conversation ID if not provided
      if (!context.conversationId) {
        context.conversationId = uuidv4();
      }

      // Get or create conversation history
      const conversationHistory = this.getConversationHistory(context.conversationId, context.userId);

      // Create agent message
      const agentMessage: AgentMessage = {
        id: uuidv4(),
        content: message,
        role: 'user',
        timestamp: new Date()
      };

      // Add to conversation history
      conversationHistory.push(agentMessage);

      // Determine which agent should handle this message
      const targetAgent = this.determineTargetAgent(message, conversationHistory);
      const agent = this.agents.get(targetAgent);

      if (!agent) {
        throw new Error(`Agent not found: ${targetAgent}`);
      }

      // Process message with the agent
      const response = await agent.processMessage(agentMessage, context);

      // Add response to conversation history
      conversationHistory.push(response.message);

      // Store updated conversation
      this.conversations.set(context.conversationId, conversationHistory);

      // Stream the response if there are listeners
      this.streamToProject(context.projectId, {
        type: 'agent_response',
        agentType: response.agentType,
        message: response.message,
        status: response.status,
        timestamp: new Date()
      });

      // Handle any tasks generated by the agent
      if (response.tasks && response.tasks.length > 0) {
        this.handleGeneratedTasks(response.tasks, context);
      }

      return response;

    } catch (error) {
      logger.error('Error in orchestrator processing message:', error);
      
      // Return error response
      return {
        agentType: AgentType.PLANNER,
        message: {
          id: uuidv4(),
          content: 'I encountered an error while processing your request. Please try again.',
          role: 'assistant',
          timestamp: new Date()
        },
        status: 'error'
      };
    }
  }

  async executeTask(
    agentType: AgentType, 
    taskType: string, 
    input: any, 
    context: ConversationContext
  ): Promise<TaskResult> {
    try {
      const agent = this.agents.get(agentType);
      if (!agent) {
        throw new Error(`Agent not found: ${agentType}`);
      }

      const task: AgentTask = {
        id: uuidv4(),
        type: taskType,
        description: `Execute ${taskType} task`,
        input,
        priority: 1,
        assignedAgent: agentType,
        status: 'pending' as any,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      const result = await agent.executeTask(task, context);

      // Stream task completion
      this.streamToProject(context.projectId, {
        type: 'task_completed',
        taskId: task.id,
        agentType,
        result,
        timestamp: new Date()
      });

      return result;

    } catch (error) {
      logger.error(`Error executing task ${taskType} with ${agentType}:`, error);
      
      return {
        taskId: 'error',
        status: 'failed' as any,
        error: error instanceof Error ? error.message : 'Unknown error',
        completedAt: new Date()
      };
    }
  }

  getConversationHistory(conversationId: string, userId: string): AgentMessage[] {
    if (!this.conversations.has(conversationId)) {
      this.conversations.set(conversationId, []);
    }
    return this.conversations.get(conversationId)!;
  }

  getSystemStatus(projectId?: string): any {
    const agentStatuses = Array.from(this.agents.entries()).map(([type, agent]) => ({
      type,
      info: agent.getAgentInfo()
    }));

    const projectInfo = projectId ? this.activeProjects.get(projectId) : null;

    return {
      agents: agentStatuses,
      activeConversations: this.conversations.size,
      activeProjects: this.activeProjects.size,
      projectInfo,
      timestamp: new Date()
    };
  }

  addStreamListener(projectId: string, listener: StreamListener): void {
    if (!this.streamListeners.has(projectId)) {
      this.streamListeners.set(projectId, []);
    }
    this.streamListeners.get(projectId)!.push(listener);
  }

  removeStreamListener(projectId: string, listener: StreamListener): void {
    const listeners = this.streamListeners.get(projectId);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
      if (listeners.length === 0) {
        this.streamListeners.delete(projectId);
      }
    }
  }

  private determineTargetAgent(message: string, history: AgentMessage[]): AgentType {
    // Simple logic to determine which agent should handle the message
    // In a more sophisticated system, this could use ML/NLP
    
    const lowerMessage = message.toLowerCase();
    
    // If it's the first message or planning-related, use Planner Agent
    if (history.length <= 1 || 
        lowerMessage.includes('plan') || 
        lowerMessage.includes('want to build') ||
        lowerMessage.includes('create') ||
        lowerMessage.includes('project')) {
      return AgentType.PLANNER;
    }

    // If conversation already started and has blueprint, use Main Agent
    const hasBlueprint = history.some(msg => 
      msg.content.includes('blueprint') || 
      msg.metadata?.blueprint
    );

    if (hasBlueprint) {
      return AgentType.MAIN;
    }

    // Default to Planner Agent for requirement gathering
    return AgentType.PLANNER;
  }

  private async handleGeneratedTasks(tasks: AgentTask[], context: ConversationContext): Promise<void> {
    // Process tasks asynchronously
    for (const task of tasks) {
      if (task.assignedAgent) {
        // Execute task in background
        this.executeTask(task.assignedAgent, task.type, task.input, context)
          .then(result => {
            logger.info(`Task ${task.id} completed with status: ${result.status}`);
          })
          .catch(error => {
            logger.error(`Task ${task.id} failed:`, error);
          });
      }
    }
  }

  private streamToProject(projectId: string | undefined, data: any): void {
    if (!projectId) return;
    
    const listeners = this.streamListeners.get(projectId);
    if (listeners) {
      listeners.forEach(listener => {
        try {
          listener(data);
        } catch (error) {
          logger.error('Error in stream listener:', error);
        }
      });
    }
  }
}